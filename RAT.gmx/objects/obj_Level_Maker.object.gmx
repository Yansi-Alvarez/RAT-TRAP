<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>speed = global.level_maker_speed;
direction = choose(0, 90, 180, 270); 

global.reference_angle = point_direction(obj_Reference_Angle.x, obj_Reference_Angle.y, obj_Level_Maker.x, obj_Level_Maker.y);

//Time allowed to generate the level
floor_generation_time = 1500/(instance_number(obj_Level_Maker) + 1);

wall_generation_time = 1800;

//Time until it changes directions
//direction_change = irandom(30) + 10;

//Probability of carving a room
room_chance = 0;

//Rooms width while generating (not actual level but rooms within level)
//generated_room_width = noone;//choose(2, 3, 4, 5);

//Rooms height while generating (not actual level but rooms within level)
//generated_room_height = noone;//choose(2, 3, 4, 5);

//Floor for the level
level_floor = obj_Concrete_Floor;
//level_floor = choose(obj_Concrete_Floor, obj_Concrete_Floor_Alt, obj_Concrete_Floor_Alt_2);

//Wall for the level
level_wall = obj_Wall_Lab_Down;

//Preventing the spawn of another level maker, will be used later
spawn_level_maker = 1;

//Preventing the spawn of another level maker, will be used later
spawn_level_maker_chance = 1;

//Size of spawn room
spawn_room_size = 1;

//Half of the width to prevent the level maker from going to the edges of the level
half_width = view_wview[1]/2;

//Half of the height to prevent the level maker from going to the edges of the level
half_height = view_hview[1]/2;

////////////////////////////////////////////////////////////////////////////////

if (global.create_boundary == false) {

    for (i = 0; i &lt; obj_Director.grid_width; i += 1) {
        //Top Section
        obj_Director.id_value = instance_create((i * global.level_maker_speed), 0, obj_Wall_Lab_Full);
        ds_grid_set(obj_Director.grid_map, i, 0, obj_Director.id_value);
    }
    
    for (j = 0; j &lt; obj_Director.grid_height; j += 1) {
        //Right Section
        obj_Director.id_value = instance_create((obj_Director.grid_width_index * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Full);
        ds_grid_set(obj_Director.grid_map, obj_Director.grid_width_index, j, obj_Director.id_value);
    }
    
    for (j = 0; j &lt; obj_Director.grid_height; j += 1) {
        //Left Section
        obj_Director.id_value = instance_create(0, (j * global.level_maker_speed), obj_Wall_Lab_Full);
        ds_grid_set(obj_Director.grid_map, 0, j, obj_Director.id_value);
    }
    
    for (i = 0; i &lt; obj_Director.grid_width; i += 1) {
        //Bottom Section
        obj_Director.id_value = instance_create((i * global.level_maker_speed), (obj_Director.grid_height_index * global.level_maker_speed), obj_Wall_Lab_Full);
        ds_grid_set(obj_Director.grid_map, i, obj_Director.grid_height_index, obj_Director.id_value);
    }
    
    global.create_boundary = true;
}

////////////////////////////////////////////////////////////////////////////////

if (global.create_central_room == false) {
    
    //Open room where the player can spawn safely, its where the level maker first spawns
    
    room_start_spawn_x = (global.center_room_width - (global.level_maker_speed * spawn_room_size));
    room_start_spawn_y = (global.center_room_height - (global.level_maker_speed * spawn_room_size));
    
    room_end_spawn_x = (global.center_room_width + (global.level_maker_speed * spawn_room_size));
    room_end_spawn_y = (global.center_room_height + (global.level_maker_speed * spawn_room_size));
    
    for (i = room_start_spawn_x; i &lt;= room_end_spawn_x; i += global.level_maker_speed) {
    
        for (j = room_start_spawn_y; j &lt;= room_end_spawn_y; j += global.level_maker_speed) {//Prevents player from being spawn in a wall
        
            obj_Director.id_value = instance_create(i, j, level_floor);
            //ds_list_add(obj_Director.id_list, obj_Director.id_value);
            //ds_grid_add(obj_Director.grid_map, (i / global.level_maker_speed), (j / global.level_maker_speed), obj_Director.id_value);
            ds_grid_set(obj_Director.grid_map, (i / global.level_maker_speed), (j / global.level_maker_speed), obj_Director.id_value);
        }
    }     
       
    global.create_central_room = true;
}

////////////////////////////////////////////////////////////////////////////////

//Create a floor at every step it takes
if (global.first_level_maker_creation == false) {

    start_point_x = (global.center_room_width + (global.level_maker_speed * (spawn_room_size + 1)));
    start_point_y = (global.center_room_height + (global.level_maker_speed * spawn_room_size));
    
    id_value = instance_create(start_point_x, start_point_y, level_floor);
    ds_grid_set(obj_Director.grid_map, (start_point_x / global.level_maker_speed), (start_point_y / global.level_maker_speed), obj_Director.id_value);
    
    x = (start_point_x + global.level_maker_speed)
    y = start_point_y
    
    global.first_level_maker_creation = true;
}

////////////////////////////////////////////////////////////////////////////////

while (floor_generation_time &gt; 0) {
        
        level_maker_chance = irandom(2)
        
        if (level_maker_chance == 0) or (level_maker_chance == 1) {
        
            path_length = choose(2, 3, 4)
            
            if (direction == 0) or (direction == 180) {
                
                repeat (path_length) {
                    
                    obj_Director.id_value = instance_create(x, y, level_floor);
                    ds_grid_set(obj_Director.grid_map, (x / global.level_maker_speed), (y / global.level_maker_speed), obj_Director.id_value);
                    x += hspeed 
                }
            }
            
            if (direction == 90) or (direction == 270) {
                
                repeat (path_length) {
                    
                    obj_Director.id_value = instance_create(x, y, level_floor);
                    ds_grid_set(obj_Director.grid_map, (x / global.level_maker_speed), (y / global.level_maker_speed), obj_Director.id_value);
                    y += vspeed
                } 
            }
            
                direction = choose(0, 90, 180, 270)
        }
        
    floor_generation_time -= 1;
    
    //Limiting level maker's movement

    //Keeps the level generator from moving too close to the right side of the room
    x = min(x, room_width - half_width); //x, 2560 - 320

    //Keeps the level generator from moving too close to the left side of the room
    x = max(half_width, x); //320, x

    //Keeps the level generator from moving too close to the botoom of the room
    y = min(y, room_height - (half_height + 16)); //y, 1920 - 240

    //Keeps the level generator from moving too close to the top of the room
    y = max((half_height + 16), y); //240, y
}

for (i = 0; i &lt; obj_Director.grid_width; i += 1) {

    for (j = 0; j &lt; obj_Director.grid_height; j += 1) {
    
    //grid_block = (ds_grid_get(obj_Director.grid_map, i, j));
    reference_angle = point_direction(obj_Reference_Angle.x, obj_Reference_Angle.y, (i * global.level_maker_speed), (j * global.level_maker_speed));
    
        if ((ds_grid_get(obj_Director.grid_map, i, j)) == 0) {

            /*if //(((ds_grid_get(obj_Director.grid_map, i + 1, j)) == 0) and 
                //((ds_grid_get(obj_Director.grid_map, i, j + 1)) == 0) and
                //((ds_grid_get(obj_Director.grid_map, i - 1, j)) == 0) and 
                //((ds_grid_get(obj_Director.grid_map, i, j - 1)) == 0)) or 
                
                (((ds_grid_get(obj_Director.grid_map, i + 1, j)).object_index == obj_Wall_Lab_Full) and 
                ((ds_grid_get(obj_Director.grid_map, i, j + 1)).object_index == obj_Wall_Lab_Full) and
                ((ds_grid_get(obj_Director.grid_map, i - 1, j)).object_index == obj_Wall_Lab_Full) and 
                ((ds_grid_get(obj_Director.grid_map, i, j - 1)).object_index == obj_Wall_Lab_Full)) {   
                
                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Full); 
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);
            } */

            if (reference_angle &gt;= 0) and (reference_angle &lt;= 44) {
            
                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Left); 
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);
            
            }
            
            if (reference_angle &gt;= 45) and (reference_angle &lt;= 134) {
            
                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Down); 
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);    
            
            }
            
            if (reference_angle &gt;= 135) and (reference_angle &lt;= 224) {
            
                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Right);
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);     
                
            }
            
            if (reference_angle &gt;= 225) and (reference_angle &lt;= 314) {

                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Up);
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);      
                
            }
            
            if (reference_angle &gt;= 315) and (reference_angle &lt;= 359) {
            
                obj_Director.id_value = instance_create((i * global.level_maker_speed), (j * global.level_maker_speed), obj_Wall_Lab_Left); 
                ds_grid_set(obj_Director.grid_map, i, j, obj_Director.id_value);    
            
            }
        }
    }
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

/*
    //Takes into account the number of level makers, it will be implemented so that the more
    //there is, the less likely more are to be spawned
    spawn_level_maker = instance_number(obj_Level_Maker);
    
    //Chances to spawn a new level maker, the higher it is, the lower the chance
    spawn_level_maker_chance = irandom(500 * (spawn_level_maker + 1));
 
    if (spawn_level_maker_chance == 0) {
        
        instance_create(x, y, obj_Level_Maker);
    }
*/    

//}

    /*
    if (level_maker_room_chance == 2) {
    
        //Room Generation
        room_chance = irandom(25);
        
        if (room_chance == 0) {
        
            //Rooms new width
            generated_room_width = choose(1, 2);
            
            //Rooms new height
            generated_room_height = choose(1, 2);
            
            //For loop to generate different sized rooms
            for (i =- generated_room_width; i &lt;= generated_room_width; i += 1) {
            
                for (j =- generated_room_height; j &lt;= generated_room_height; j += 1) {
                
                    obj_Director.id_value = instance_create(x + (i * global.level_maker_speed), y + (j * global.level_maker_speed), level_floor);
                    ds_list_add(obj_Director.id_list, obj_Director.id_value);
                    ds_grid_add(obj_Director.grid_map, ((x / global.level_maker_speed) - 1), ((y / global.level_maker_speed) - 1), obj_Director.id_value);
                }
            }
        }
    }*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_number(obj_Level_Maker) == 1) { //If this is the last level maker
    
    //instance_create(x, y, obj_Server);
    //scr_level_walls(level_floor, level_maker_speed, level_wall);
    //scr_level_walls(level_floor, level_maker_speed, obj_Wall_Lab_Down);
    //generation = false;
    //scr_level_walls(level_floor, level_maker_speed, obj_Wall_Lab_Down);
}
/*
if (instance_number(obj_Level_Maker) == 0) {

    global.generation = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
